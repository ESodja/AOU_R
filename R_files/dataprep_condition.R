### This file takes a condition data input and formats it for connection to other dataframes with other data sources, or for analysis and plotting.

## Grab the condition data with the unique data_id and pull it in 
# this rebuilds the data structure to put it in an easier format 
# From the inside-out:
#  Define a function that runs eval(parse(text=x)) -- this will take the text entered in the variable x and 
#     turn it into a command that R will run
#  Take the data_id value from master.R, paste it into the default variable name generated by the SQL code from
#     the database builder, and run that through the defined function
#  sapply() applies the function to the value from the  paste0 function
#  t() transposes the output -- this is necessary because the database builder output is in an archaic format 
#  that does everyting backward
condmat <- t(sapply(paste0('dataset_', data_id, '_condition_df'), function(x) eval(parse(text=x))))

# grabs the column names for later use
colnms <- colnames(condmat)

# defines a new dataframe that grabs the rows and columns of the output:
#   define a two-variable function that pulls rows and columns from the imported data and puts it in a nice, 
#   simple data frame, which is the standard base format for R
conddata <- data.frame(mapply(function(x,y) x=condmat[[y]], x=colnms, y=1:length(colnms)))

# List of unique condition concepts we are working with
condnames <- unique(conddata['standard_concept_name'])

# Question for the user -- if you are comparing presence/absence of two conditions, we will do something different
multicond = readline(prompt='Are you comparing 2 conditions? ( Y / n )')

# if the answer is 'yes' (str_to_upper converts lower case letters to upper)
if (str_to_upper(multicond) == 'Y'){
    # The next chunk takes all the condition names and breaks them into individual words to try to identify your two conditions
    # This is necessary because condition names are at the lowest level, e.g. something like "Heart Disease" is listed 
    # under several different more specific names.
    # This first part gets a list of conditions for the user to choose from
    # splits all of the condition names into their component words
    words <- strsplit(condnames[,1], "[ ,.\\(\\)\"]") # <- this weird set of symbols is a regular expression that breaks things out by spaces (defines words as letters between spaces)
    # looks for words that are capitalized -- may not be helpful if your condition isn't named after someone, so you may want to comment this out
    words <- regmatches(unlist(words), gregexpr("\\b[A-Z]\\w+", unlist(words))) 
    # sorts words in condition names by how many occurrences there are in the unique condition names
    choicewords <- sort(table(unlist(words), exclude=""), decreasing=TRUE)
    # print this sorted list
    print(choicewords)
    # Get the user's selection of which words apply to their condition(s) of interest
    chosen = readline(prompt=paste('Which of the above are the name of your conditions you would like to test? Enter two numbers, separated by a comma (', paste(1:length(choicewords), collapse=','), ')'))
    # Converts the user selection to a command that is passed as a subsetting index to the available choices
    chosen.words = choicewords[eval(parse(text=paste0('c(', chosen, ')')))]
    # define a binary column for both conditions -- 0 means condition absent, 1 means condition is present
    conddata$cond1=0
    # anything that matches words with the first indicated condition will change cond1 column to 1 (same for cond2 below)
    conddata$cond1[unlist(lapply(strsplit(conddata$standard_concept_name, "[ ,.\\(\\)\"]"), function(x) any(regmatches(unlist(x), gregexpr("\\b[A-Z]\\w+", unlist(x))) %in% names(chosen.words[1]))))==TRUE] <- 1
    conddata$cond2=0
    conddata$cond2[unlist(lapply(strsplit(conddata$standard_concept_name, "[ ,.\\(\\)\"]"), function(x) any(regmatches(unlist(x), gregexpr("\\b[A-Z]\\w+", unlist(x))) %in% names(chosen.words[2]))))==TRUE] <- 1
    # reset names of the data frame to allow later queries
    names(conddata) = c('person_id', 'standard_concept_name', names(chosen.words[1]), names(chosen.words[2]))
    # If any individuals have more than one record, we can make sure that any presence is recorded and get rid of the absence if any presence is indicated
    conddat1 <- tapply(conddata[,3], conddata[,1], max)
    conddat2 <- tapply(conddata[,4], conddata[,1], max)
    # connects the conditions together to ensure double positives are counted 
    conddat.unity <- merge(data.frame(person_id=names(conddat1), conddat1), data.frame(person_id = names(conddat2), conddat2), by='person_id', all=TRUE)
    conddat.unity[is.na(conddat.unity)] <- 0
}
